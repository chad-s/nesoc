KCPSM6 Assembler log file for program 'Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\wii_classic.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 02 Dec 2015
Assembly timestamp: 00:46:26

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 0D7 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 216
Memory locations available: 3880


Assembly listing

 Addr Code                      Instruction

 000                            ;------------------------------------------------------------------------------------------
 000                            ;
 000                            ; INTRODUCTION
 000                            ; ------------
 000                            ;
 000                            ; .....
 000                            ;
 000                            ;------------------------------------------------------------------------------------------
 000                            ; Hardware Constants
 000                            ;------------------------------------------------------------------------------------------
 000                            ;
 000                            ; The CONSTANT directive below define the 7-Bit I2C addresses of the Wii Classic Controller
 000                            ;
 000                            CONSTANT wii_classic_address, 52  ; NINTENDO WII Classic Controller
 000                            ;
 000                            ;
 000                            ;------------------------------------------------------------------------------------------
 000                            ; Port Addresses
 000                            ;------------------------------------------------------------------------------------------
 000                            ;
 000                            CONSTANT PA_BYTE_0, 00            ; Data read from controller
 000                            CONSTANT PA_BYTE_1, 01
 000                            CONSTANT PA_BYTE_2, 02
 000                            CONSTANT PA_BYTE_3, 03
 000                            CONSTANT PA_BYTE_4, 04
 000                            CONSTANT PA_BYTE_5, 05
 000                            ;
 000                            ;
 000                            ;------------------------------------------------------------------------------------------
 000                            ; Registers
 000                            ;------------------------------------------------------------------------------------------
 000                            ;
 000                            ; The following registers within the currently active bank are used by these routines....
 000                            ;
 000                            ;    s0, s1, s5, sD and sF
 000                            ;
 000                            NAMEREG s7, Byte0                 ;Bytes read from the controller
 000                            NAMEREG s8, Byte1
 000                            NAMEREG s9, Byte2
 000                            NAMEREG sA, Byte3
 000                            NAMEREG sB, Byte4
 000                            NAMEREG sC, Byte5
 000                            ;
 000                            ;
 000                            ;------------------------------------------------------------------------------------------
 000                            ; Routine to initialize the ouput ports and the controller
 000                            ;------------------------------------------------------------------------------------------
 000                            ;
 000                            ADDRESS 000
 000  22004                     JUMP 004[init]                    ; workaround to avoid location 3 corruption
 001  22004                     JUMP 004[init]                    ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                     JUMP 004[init]                    ; Ken Chapman and is known to be in 2014.2
 003  22004                     JUMP 004[init]                    ; Address 003 can be corrupted by Vivado HW manager
 004                            ;
 004  20077               init: CALL 077[delay_1ms]               ; Give controller some time to get going
 005                            ;
 005  20053                     CALL 053[wii_classic_init]        ; Initialize the controller
 006  3A023                     JUMP C, 023[error_handler2]
 007                            ;
 007  01600                     LOAD s6, 00                       ; Initialize (clear) out ports
 008  2D605                     OUTPUT s6, 05[PA_BYTE_5]
 009  2D604                     OUTPUT s6, 04[PA_BYTE_4]
 00A  2D603                     OUTPUT s6, 03[PA_BYTE_3]
 00B  2D602                     OUTPUT s6, 02[PA_BYTE_2]
 00C  2D601                     OUTPUT s6, 01[PA_BYTE_1]
 00D  2D600                     OUTPUT s6, 00[PA_BYTE_0]
 00E                            ;
 00E                            ;------------------------------------------------------------------------------------------
 00E                            ; MAIN: Read controller inputs, convert to output format,
 00E                            ; and send the data out.
 00E                            ;------------------------------------------------------------------------------------------
 00E                            ;
 00E  2002B               main: CALL 02B[wii_classic_read]
 00F  3A018                     JUMP C, 018[error_handler]
 010  2DC05                     OUTPUT sC[Byte5], 05[PA_BYTE_5]
 011  2DB04                     OUTPUT sB[Byte4], 04[PA_BYTE_4]
 012  2DA03                     OUTPUT sA[Byte3], 03[PA_BYTE_3]
 013  2D902                     OUTPUT s9[Byte2], 02[PA_BYTE_2]
 014  2D801                     OUTPUT s8[Byte1], 01[PA_BYTE_1]
 015  2D700                     OUTPUT s7[Byte0], 00[PA_BYTE_0]
 016  20077                     CALL 077[delay_1ms]
 017  2200E                     JUMP 00E[main]
 018                            ;
 018                            ;
 018                            ;------------------------------------------------------------------------------------------
 018                            ; Handle errors quasi-eligantly. This will toggle the DPad output every second. Possible
 018                            ; enhancement would be to designate an error-code output port.
 018                            ;------------------------------------------------------------------------------------------
 018                            ;
 018  2007F      error_handler: CALL 07F[delay_1s]
 019  01600                     LOAD s6, 00
 01A  2D604                     OUTPUT s6, 04[PA_BYTE_4]
 01B  016FF                     LOAD s6, FF
 01C  2D605                     OUTPUT s6, 05[PA_BYTE_5]
 01D                            ;
 01D  2007F                     CALL 07F[delay_1s]
 01E  016FF                     LOAD s6, FF
 01F  2D604                     OUTPUT s6, 04[PA_BYTE_4]
 020  01600                     LOAD s6, 00
 021  2D605                     OUTPUT s6, 05[PA_BYTE_5]
 022                            ;
 022  22018                     JUMP 018[error_handler]
 023                            ;
 023  2007F     error_handler2: CALL 07F[delay_1s]
 024  2D605                     OUTPUT s6, 05[PA_BYTE_5]
 025  2D604                     OUTPUT s6, 04[PA_BYTE_4]
 026                            ;
 026  2007F                     CALL 07F[delay_1s]
 027  015FF                     LOAD s5, FF
 028  2D505                     OUTPUT s5, 05[PA_BYTE_5]
 029  2D504                     OUTPUT s5, 04[PA_BYTE_4]
 02A                            ;
 02A  22023                     JUMP 023[error_handler2]
 02B                            ;
 02B                            ;------------------------------------------------------------------------------------------
 02B                            ; Routine to read from the Wii Classic Controller
 02B                            ;------------------------------------------------------------------------------------------
 02B                            ; This routine will read the 6-byte status from the Wii Classic Controller
 02B                            ; registers and return it in registers 's8' through 'sD'.
 02B                            ;
 02B                            ; If for some reason communication is unsuccessful then the CARRY flag will
 02B                            ; be set and this could be tested by your code and used to take appropriate actions.
 02B                            ;
 02B  20089   wii_classic_read: CALL 089[I2C_initialise]          ;ensure bus state and initialise 'sF'
 02C  2008D                     CALL 08D[I2C_start]               ;bus start (S)
 02D                            ;
 02D  01552                     LOAD s5, 52[wii_classic_address]  ;device base address (7-bits)
 02E  14506                     SL0 s5                            ;Write operation (LSB = 0)
 02F  2009A                     CALL 09A[I2C_Tx_byte]             ;Transmit address with write
 030  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 031  39000                     RETURN C                          ;Return on failure (Carry flag set)
 032                            ;
 032  01500                     LOAD s5, 00                       ;Resetting the controller data pointer
 033  2009A                     CALL 09A[I2C_Tx_byte]
 034  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 035  39000                     RETURN C                          ;Return on failure (Carry flag set)
 036                            ;
 036  20094                     CALL 094[I2C_stop]
 037  20077                     CALL 077[delay_1ms]
 038                            ;
 038  20089                     CALL 089[I2C_initialise]
 039  2008D                     CALL 08D[I2C_start]               ;bus restart (Sr)
 03A                            ;
 03A  01552                     LOAD s5, 52[wii_classic_address]  ;device base address (7-bits)
 03B  14507                     SL1 s5                            ;Read operation (LSB = 1)
 03C  2009A                     CALL 09A[I2C_Tx_byte]             ;Transmit address with write
 03D  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 03E  39000                     RETURN C                          ;Return on failure (Carry flag set)
 03F                            ;
 03F  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 040  00750                     LOAD s7[Byte0], s5
 041  200A9                     CALL 0A9[I2C_Tx_ACK]
 042  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 043  00850                     LOAD s8[Byte1], s5
 044  200A9                     CALL 0A9[I2C_Tx_ACK]
 045  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 046  00950                     LOAD s9[Byte2], s5
 047  200A9                     CALL 0A9[I2C_Tx_ACK]
 048  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 049  00A50                     LOAD sA[Byte3], s5
 04A  200A9                     CALL 0A9[I2C_Tx_ACK]
 04B  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 04C  00B50                     LOAD sB[Byte4], s5
 04D  200A9                     CALL 0A9[I2C_Tx_ACK]
 04E  200A4                     CALL 0A4[I2C_Rx_byte]             ;Read data from controller
 04F  00C50                     LOAD sC[Byte5], s5
 050                            ;
 050  200AF                     CALL 0AF[I2C_Tx_NACK]             ;Transmit NACK to end read operation
 051  20094                     CALL 094[I2C_stop]                ;transmit stop (P)
 052  25000                     RETURN                            ;with Carry flag reset
 053                            ;------------------------------------------------------------------------------------------
 053                            ; Routine to initialize the wii classic controller
 053                            ;------------------------------------------------------------------------------------------
 053                            ;
 053                            ;
 053  20089   wii_classic_init: CALL 089[I2C_initialise]          ;ensure bus state and initialise 'sF'
 054  2008D                     CALL 08D[I2C_start]               ;bus start (S)
 055                            ;
 055  01552                     LOAD s5, 52[wii_classic_address]  ;device base address (7-bits)
 056  14506                     SL0 s5                            ;Write operation (LSB = 0)
 057  2009A                     CALL 09A[I2C_Tx_byte]             ;Transmit address with write
 058  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 059  39000                     RETURN C                          ;Return on failure (Carry flag set)
 05A                            ;
 05A  015F0                     LOAD s5, F0                       ;Data to be written to controller
 05B  2009A                     CALL 09A[I2C_Tx_byte]
 05C  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 05D  39000                     RETURN C                          ;Return on failure (Carry flag set)
 05E                            ;
 05E  01555                     LOAD s5, 55                       ;Data to be written to controller
 05F  2009A                     CALL 09A[I2C_Tx_byte]
 060  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 061  39000                     RETURN C                          ;Return on failure (Carry flag set)
 062                            ;
 062  20094                     CALL 094[I2C_stop]                ;transmit stop (P)
 063  20077                     CALL 077[delay_1ms]               ;time for write to complete
 064                            ;
 064                            ;
 064  20089                     CALL 089[I2C_initialise]          ;ensure bus state and initialise 'sF'
 065  2008D                     CALL 08D[I2C_start]               ;bus start (S)
 066                            ;
 066  01552                     LOAD s5, 52[wii_classic_address]  ;device base address (7-bits)
 067  14506                     SL0 s5                            ;Write operation (LSB = 0)
 068  2009A                     CALL 09A[I2C_Tx_byte]             ;Transmit address with write
 069  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 06A  39000                     RETURN C                          ;Return on failure (Carry flag set)
 06B                            ;
 06B  015FB                     LOAD s5, FB                       ;Data to be written to controller
 06C  2009A                     CALL 09A[I2C_Tx_byte]
 06D  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 06E  39000                     RETURN C                          ;Return on failure (Carry flag set)
 06F                            ;
 06F  01500                     LOAD s5, 00                       ;Data to be written to controller
 070  2009A                     CALL 09A[I2C_Tx_byte]
 071  200B1                     CALL 0B1[I2C_Rx_ACK]              ;Receive ACK
 072  39000                     RETURN C                          ;Return on failure (Carry flag set)
 073                            ;
 073  20094                     CALL 094[I2C_stop]                ;transmit stop (P)
 074  20077                     CALL 077[delay_1ms]               ;time for write to complete
 075                            ;
 075  030FF                     AND s0, FF                        ;clear carry flag (write successful)
 076  25000                     RETURN                            ;with Carry flag reset
 077                            ;
 077                            ;
 077                            INCLUDE "Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\soft_delays_100mhz.psm"["soft_delays_100mhz.psm"]
 077                            ;
 077                            ;------------------------------------------------------------------------------------------
 077                            ; Copyright © 2012-2013, Xilinx, Inc.
 077                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 077                            ; protected under U.S. and international copyright and other intellectual property laws.
 077                            ;------------------------------------------------------------------------------------------
 077                            ;
 077                            ; Disclaimer:
 077                            ; This disclaimer is not a license and does not grant any rights to the materials
 077                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 077                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 077                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 077                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 077                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 077                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 077                            ; (whether in contract or tort, including negligence, or under any other theory
 077                            ; of liability) for any loss or damage of any kind or nature related to, arising
 077                            ; under or in connection with these materials, including for any direct, or any
 077                            ; indirect, special, incidental, or consequential loss or damage (including loss
 077                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 077                            ; of any action brought by a third party) even if such damage or loss was
 077                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 077                            ;
 077                            ; CRITICAL APPLICATIONS
 077                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 077                            ; application requiring fail-safe performance, such as life-support or safety
 077                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 077                            ; related to the deployment of airbags, or any other applications that could lead
 077                            ; to death, personal injury, or severe property or environmental damage
 077                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 077                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 077                            ; subject only to applicable laws and regulations governing limitations on product
 077                            ; liability.
 077                            ;
 077                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 077                            ;
 077                            ;------------------------------------------------------------------------------------------
 077                            ;
 077                            ;             _  ______ ____  ____  __  __  __
 077                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 077                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 077                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 077                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 077                            ;
 077                            ;
 077                            ;                PicoBlaze Reference Design.
 077                            ;
 077                            ;
 077                            ; Ken Chapman - Xilinx Ltd
 077                            ;
 077                            ; 6th September 2012 - Initial version
 077                            ;    18th March 2013 - Addition of 20ms delay
 077                            ;
 077                            ; This file contains routines that implement delays in software. It should be recognised
 077                            ; that the delay periods are the result of executing instructions, and because every
 077                            ; instruction takes 2 clock cycles to execute, it is possible to determine the exact
 077                            ; delay period. However, besides the obvious dependency on the clock frequency, it
 077                            ; should also be recognised that any interrupts to KCPSM6 (or use of sleep mode) will
 077                            ; impact the timing. In general, it is better only to use soft delay routines in
 077                            ; situations where approximate timing is adequate; in those situations KCPSM6 will often
 077                            ; exceed your requirements.
 077                            ;
 077                            ;
 077                            ;------------------------------------------------------------------------------------------
 077                            ; Software Delays based on 100MHz clock
 077                            ;------------------------------------------------------------------------------------------
 077                            ;
 077                            ; The number of iterations of a delay loop required to form each delay required are
 077                            ; loaded into the register set [s2,s1,s0] and then the delay loop is started.
 077                            ;
 077                            ; Registers used s0, s1, s2
 077                            ;
 077                            ; 1ms is 10,000 x 100ns     (10,000 = 002710 hex)
 077                            ;
 077  01200          delay_1ms: LOAD s2, 00
 078  01127                     LOAD s1, 27
 079  01010                     LOAD s0, 10
 07A  22083                     JUMP 083[software_delay]
 07B                            ;
 07B                            ; 20ms is 200,000 x 100ns     (200,000 = 030D40 hex)
 07B                            ;
 07B  01203         delay_20ms: LOAD s2, 03
 07C  0110D                     LOAD s1, 0D
 07D  01040                     LOAD s0, 40
 07E  22083                     JUMP 083[software_delay]
 07F                            ;
 07F                            ;
 07F                            ; 1s is 10,000,000 x 100ns     (10,000,000 = 989680 hex)
 07F                            ;
 07F  01298           delay_1s: LOAD s2, 98
 080  01196                     LOAD s1, 96
 081  01080                     LOAD s0, 80
 082  22083                     JUMP 083[software_delay]
 083                            ;
 083                            ; The delay loop decrements [s2,s1,s0] until it reaches zero
 083                            ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 083                            ;
 083  00000     software_delay: LOAD s0, s0                       ;pad loop to make it 10 clock cycles (5 instructions)
 084  19001                     SUB s0, 01[1'd]
 085  1B100                     SUBCY s1, 00[0'd]
 086  1B200                     SUBCY s2, 00[0'd]
 087  36083                     JUMP NZ, 083[software_delay]
 088  25000                     RETURN 
 089                            ;
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ; End of 'soft_delays_100mhz.psm'
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            INCLUDE "Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\i2c_routines.psm"["i2c_routines.psm"]
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ; Copyright © 2011-2012, Xilinx, Inc.
 089                            ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 089                            ; protected under U.S. and international copyright and other intellectual property laws.
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            ; Disclaimer:
 089                            ; This disclaimer is not a license and does not grant any rights to the materials
 089                            ; distributed herewith. Except as otherwise provided in a valid license issued to
 089                            ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 089                            ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 089                            ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 089                            ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 089                            ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 089                            ; (whether in contract or tort, including negligence, or under any other theory
 089                            ; of liability) for any loss or damage of any kind or nature related to, arising
 089                            ; under or in connection with these materials, including for any direct, or any
 089                            ; indirect, special, incidental, or consequential loss or damage (including loss
 089                            ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 089                            ; of any action brought by a third party) even if such damage or loss was
 089                            ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 089                            ;
 089                            ; CRITICAL APPLICATIONS
 089                            ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 089                            ; application requiring fail-safe performance, such as life-support or safety
 089                            ; devices or systems, Class III medical devices, nuclear facilities, applications
 089                            ; related to the deployment of airbags, or any other applications that could lead
 089                            ; to death, personal injury, or severe property or environmental damage
 089                            ; (individually and collectively, "Critical Applications"). Customer assumes the
 089                            ; sole risk and liability of any use of Xilinx products in Critical Applications,
 089                            ; subject only to applicable laws and regulations governing limitations on product
 089                            ; liability.
 089                            ;
 089                            ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            ;
 089                            ;             _  ______ ____  ____  __  __  __
 089                            ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 089                            ;            | ' / |   | |_) \___ \| |\/| | '_ \
 089                            ;            | . \ |___|  __/ ___) | |  | | (_) )
 089                            ;            |_|\_\____|_|   |____/|_|  |_|\___/
 089                            ;
 089                            ;
 089                            ;                PicoBlaze Reference Design.
 089                            ;
 089                            ;
 089                            ; Routines for General Purpose I2C Communication
 089                            ;
 089                            ; Ken Chapman - Xilinx Ltd
 089                            ;
 089                            ; 9th March 2012 - Initial Version
 089                            ; 12th October 2012 - Adjustments to values assigned to constant directives
 089                            ; 16th October 2012 - Code optimisation (lowest level signal drive routines)
 089                            ; 25th October 2012 - Correct definition of a binary value (functionally identical)
 089                            ; 6th November 2012 - Correction to comment only
 089                            ;
 089                            ;
 089                            ;     NOTE - This is not a standalone PSM file. Include this file in a program that
 089                            ;            then calls these routines and works with the values in scratch pad memory.
 089                            ;
 089                            ;                INCLUDE "i2c_routines.psm"
 089                            ;
 089                            ;
 089                            ;     IMPORTANT - These routines interact with input and output ports which must
 089                            ;                 be appropriately defined to drive and read the physical I2C
 089                            ;                 signals. Four CONSTANT directives must define values consistent
 089                            ;                 with your port definitions and a further CONSTANT must be defined
 089                            ;                 that is related to the frequency of the clock being applied to
 089                            ;                 KCPSM6 in your design (Please see descriptions below).
 089                            ;
 089                            ;
 089                            ; INTRODUCTION
 089                            ; ------------
 089                            ;
 089                            ; The following routines implement an I2C 'Master' with a communication data rate
 089                            ; approaching (but not exceeding) 100KHz. The I2C bus connects to the FPGA I/O
 089                            ; pins which must in turn be connected to KCPSM6 input and output ports. Therefore
 089                            ; your hardware design must be appropriate before these routines can be used and
 089                            ; these routines need to know which ports you have allocated for I2C in your design.
 089                            ;
 089                            ; With the hardware in place, the routines provide the ability to perform each of the
 089                            ; actions generally required for an I2C transaction including bus idle, Start (S),
 089                            ; Repeated Start (Sr), Stop (P), Transmission of Acknowledge (ACK) or No Acknowledge
 089                            ; (NACK), receiving and testing of Acknowledge (ACK) from a slave and of course the
 089                            ; ability to transmit and receive bytes used for addressing, commands and data.
 089                            ;
 089                            ; It is assumed that you are familiar with I2C, so the descriptions contained in this
 089                            ; file are concerned primarily with how KCPSM6 is used to implement the signaling and
 089                            ; elements of the transactions rather than to teach I2C itself. In the end, it is the
 089                            ; sequence in which these routines are invoked that will result in successful
 089                            ; communication with a slave device and that requires an understanding of the needs
 089                            ; of each particular slave to implement correctly (i.e. a study of data sheets for
 089                            ; slave devices when writing higher level code).
 089                            ;
 089                            ; NOTE - As provided, these routines assume that KCPSM6 is the only I2C master connected
 089                            ;        to the bus. A multiple master implementation would be possible but these routines
 089                            ;        are not suitable in such arrangements.
 089                            ;
 089                            ;
 089                            ;
 089                            ; Code typical of an I2C write of data to a slave using the routines provided...
 089                            ;
 089                            ;    CALL I2C_initialise
 089                            ;    CALL I2C_start
 089                            ;    LOAD s5, slave_address       ;7-bit slave address
 089                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    JUMP C, communication_fail   ;did the slave respond?
 089                            ;    LOAD s5, data_byte1
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    LOAD s5, data_byte2
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    CALL I2C_stop
 089                            ;
 089                            ;
 089                            ; Code typical of an I2C read of data from a slave using the routines provided...
 089                            ;
 089                            ;    CALL I2C_initialise
 089                            ;    CALL I2C_start
 089                            ;    LOAD s5, slave_address       ;7-bit slave address
 089                            ;    SL0 s5                       ;Write operation signified by LSB = 0
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    JUMP C, communication_fail   ;did the slave respond?
 089                            ;    LOAD s5, slave_command
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    CALL I2C_start               ;bus restart (Sr)
 089                            ;    LOAD s5, slave_address       ;7-bit slave address
 089                            ;    SL1 s5                       ;Read operation signified by LSB = 1
 089                            ;    CALL I2C_Tx_byte
 089                            ;    CALL I2C_Rx_ACK
 089                            ;    CALL I2C_Rx_byte
 089                            ;    STORE s5, data1
 089                            ;    CALL I2C_Tx_ACK
 089                            ;    CALL I2C_Rx_byte
 089                            ;    STORE s5, data2
 089                            ;    CALL I2C_Tx_NACK             ;transmit NACK before Stop
 089                            ;    CALL I2C_stop
 089                            ;
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ; Hardware
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            ; Clock
 089                            ; -----
 089                            ;
 089                            ; All KCPSM6 instructions take 2 clock cycles to execute and it is this predictability
 089                            ; that these routines exploit to ensure that the I2C communication rate does not exceed
 089                            ; 100KHz. However, these routines will only implement the correct timing if something
 089                            ; related to the frequency of the clock provide to KCPSM6 is known and the CONSTANT
 089                            ; directive below must be defined correctly to achieve that.
 089                            ;
 089                            CONSTANT I2C_time_reference, 24'd
 089                            ;
 089                            ;  I2C_time_reference =  ( fclk - 6 ) / 4
 089                            ;
 089                            ;   Where...
 089                            ;     'fclk' is the clock frequency applied to KCPSM6 in MHz.
 089                            ;     Any non-integer result should be rounded up.
 089                            ;     Typical values....
 089                            ;
 089                            ;          fclk (MHz)      I2C_time_reference
 089                            ;            50                  11'd
 089                            ;            80                  19'd
 089                            ;           100                  24'd
 089                            ;           200                  49'd
 089                            ;
 089                            ;
 089                            ;
 089                            ; I2C Bus and KCPSM6 ports
 089                            ; ------------------------
 089                            ;
 089                            ; An I2C bus consists of two signals called 'CLK' and 'DATA' or something similar. Both
 089                            ; signals need to be connected to the FPGA via 'open collector' style bidirectional I/O
 089                            ; pins with a pull-up resistor (typically an external resistor but the built in pull-up
 089                            ; resistor of the IOB may also be enabled in some cases). These I/O pins must then be
 089                            ; connected to a KCPSM6 input port and KCPSM6 output port such that both signals can
 089                            ; be both driven and read.
 089                            ;
 089                            ;  The input port used to read the logic levels on the CLK and DATA signals external
 089                            ;  to the FPGA.
 089                            ;
 089                            ;  The output port is used to control the output drive of the CLK and DATA pins.
 089                            ;    Since the pins are 'open collector' style then when KCPSM6 outputs...
 089                            ;      '0' will result in the signal being driven Low.
 089                            ;      '1' will result in the pin becoming tri-state (Z) so the signal will be pulled
 089                            ;          High by the resistor or can be driven or held low by a slave device.
 089                            ;
 089                            ; In a typical VHDL based design the following snippets of code could be inserted at the
 089                            ; appropriate places to define the I2C pins and connection to KCPSM6...
 089                            ;
 089                            ;   entity <name>
 089                            ;   Port (   i2c_clk : inout std_logic;
 089                            ;           i2c_data : inout std_logic;
 089                            ;
 089                            ;
 089                            ;   signal  drive_i2c_clk : std_logic;
 089                            ;   signal drive_i2c_data : std_logic;
 089                            ;
 089                            ;
 089                            ;   i2c_clk  <= '0' when drive_i2c_clk = '0' else 'Z';
 089                            ;   i2c_data <= '0' when drive_i2c_data = '0' else 'Z';
 089                            ;
 089                            ;
 089                            ;   input_ports: process(clk)
 089                            ;   begin
 089                            ;     if clk'event and clk = '1' then
 089                            ;       case port_id(1 downto 0) is
 089                            ;
 089                            ;         -- Read I2C Bus at port address 02 hex
 089                            ;         when "10" =>    in_port(0) <= i2c_clk;
 089                            ;                         in_port(1) <= i2c_data;
 089                            ;
 089                            ;
 089                            ;   output_ports: process(clk)
 089                            ;   begin
 089                            ;     if clk'event and clk = '1' then
 089                            ;       if write_strobe = '1' then
 089                            ;
 089                            ;         -- Write to I2C Bus at port address 08 hex
 089                            ;         if port_id(3) = '1' then
 089                            ;           drive_i2c_clk <= out_port(0);
 089                            ;           drive_i2c_data <= out_port(1);
 089                            ;         end if;
 089                            ;
 089                            ;
 089                            ;
 089                            ; To correspond with the definition of the input and output ports, the four CONSTANT
 089                            ; directives below must be set correctly before these I2C routines are used. The
 089                            ; values shown below correspond with the VHDL snippets above.
 089                            ;
 089                            CONSTANT I2C_input_port, 02       ;port address of I2C input port
 089                            CONSTANT I2C_output_port, 20      ;port address of I2C output port
 089                            ;
 089                            CONSTANT I2C_clk, 00000001'b      ;Bit to which CLK is assigned on both ports
 089                            CONSTANT I2C_data, 00000010'b     ;Bit to which DATA is assigned on both ports
 089                            ;
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ; Registers
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            ; The following registers within the currently active bank are used by these routines....
 089                            ;
 089                            ;    s0, s1, s5 and sF
 089                            ;
 089                            ;
 089                            ; IMPORTANT - Register 'sF' is used to control and remember the drive values of the CLK
 089                            ;             and DATA signals so its contents MUST NOT be altered between calls to the
 089                            ;             various routines used to construct a complete I2C transaction. The routine
 089                            ;             called 'I2C_initialise' is typically used before starting any transaction
 089                            ;             as it will initialise 'sF' as well as the actual I2C interface.
 089                            ;
 089                            ;
 089                            ;------------------------------------------------------------------------------------------
 089                            ; Routine to initialise the CLK and DATA signals (and 'sF')
 089                            ;------------------------------------------------------------------------------------------
 089                            ;
 089                            ; Places CLK and DATA into tri-state (Z) so that both lines reach idle High level.
 089                            ; This also initialises register sF ready for other routines forming a transaction.
 089                            ;
 089                            ; This routine MUST be used before starting the first I2C transaction and before any
 089                            ; further transaction if the contents of register 'sF' have been compromised since the
 089                            ; end of the last I2C transaction.
 089                            ;
 089  01F01     I2C_initialise: LOAD sF, 01[I2C_clk]              ;CLK = Z
 08A  05F02                     OR sF, 02[I2C_data]               ;DATA = Z
 08B  2DF20                     OUTPUT sF, 20[I2C_output_port]
 08C  25000                     RETURN 
 08D                            ;
 08D                            ;
 08D                            ;------------------------------------------------------------------------------------------
 08D                            ; Routine issue an I2C Start (S) or Repeated Start (Sr) condition.
 08D                            ;------------------------------------------------------------------------------------------
 08D                            ;
 08D                            ; Used to begin any I2C transaction or performed during a transaction when changing the
 08D                            ; from an write to a read.
 08D                            ;
 08D                            ; The Start (S) or Repeated Start (Sr) condition is signified by a High to Low transition
 08D                            ; of the DATA line whilst the CLK line is High.
 08D                            ;
 08D  200C1          I2C_start: CALL 0C1[I2C_data_Z]              ;DATA = Z (High)
 08E  200B8                     CALL 0B8[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 08F  200CE                     CALL 0CE[I2C_delay_5us]           ;delay before start (S)
 090  200BE                     CALL 0BE[I2C_data_Low]            ;High to How transition on DATA whilst CLK is High
 091  200CF                     CALL 0CF[I2C_delay_4us]
 092  200B4                     CALL 0B4[I2C_clk_Low]             ;CLK = 0 (plus 5us delay)
 093  25000                     RETURN 
 094                            ;
 094                            ;
 094                            ;------------------------------------------------------------------------------------------
 094                            ; Routine issue an I2C Stop (P) condition
 094                            ;------------------------------------------------------------------------------------------
 094                            ;
 094                            ; Used to end any I2C transaction.
 094                            ;
 094                            ; The Stop (S) condition is signified by a Low to High transition of the DATA line whilst
 094                            ; the CLK line is High.
 094                            ;
 094                            ; Note that following this routine the CARRY flag is '0' and can be used to confirm a
 094                            ; good I2C communication (see 'I2C_Rx_ACK' routine).
 094                            ;
 094  200BE           I2C_stop: CALL 0BE[I2C_data_Low]            ;DATA = 0
 095  200CE                     CALL 0CE[I2C_delay_5us]
 096  200B8                     CALL 0B8[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 097  200CF                     CALL 0CF[I2C_delay_4us]
 098  200C1                     CALL 0C1[I2C_data_Z]              ;DATA = Z (High)
 099  25000                     RETURN 
 09A                            ;
 09A                            ;
 09A                            ;------------------------------------------------------------------------------------------
 09A                            ; Routine to transmit one byte from the KCPSM6 master to a slave
 09A                            ;------------------------------------------------------------------------------------------
 09A                            ;
 09A                            ; The byte to be transmitted must be provided in register 's5'.
 09A                            ;
 09A                            ; The byte is transmitted most significant bit (MSB) first. As each of the 8 bits are
 09A                            ; presented to the DATA line the CLK line is pulsed High.
 09A                            ;
 09A  01180        I2C_Tx_byte: LOAD s1, 80[10000000'b]           ;8-bits to transmit starting with MSB
 09B  0C510    I2C_Tx_next_bit: TEST s5, s1                       ;test data bit for High or Low
 09C  3609F                     JUMP NZ, 09F[I2C_Tx1]
 09D  200BE                     CALL 0BE[I2C_data_Low]            ;DATA = 0
 09E  220A0                     JUMP 0A0[I2C_Tx_tsu]
 09F  200C1            I2C_Tx1: CALL 0C1[I2C_data_Z]              ;DATA = Z (High)
 0A0  200AA         I2C_Tx_tsu: CALL 0AA[I2C_clk_pulse]           ;generate clock pulse with delays
 0A1  1410E                     SR0 s1                            ;move to next bit
 0A2  39000                     RETURN C                          ;have 8 bits been transmitted?
 0A3  2209B                     JUMP 09B[I2C_Tx_next_bit]
 0A4                            ;
 0A4                            ;
 0A4                            ;------------------------------------------------------------------------------------------
 0A4                            ; Routine to receive one byte from a slave
 0A4                            ;------------------------------------------------------------------------------------------
 0A4                            ;
 0A4                            ; The byte received will be returned in register 's5'.
 0A4                            ;
 0A4                            ; The byte is received most significant bit (MSB) first. Each  of the 8 bits are sampled
 0A4                            ; as the CLK line is pulsed High.
 0A4                            ;
 0A4  01108        I2C_Rx_byte: LOAD s1, 08[8'd]                  ;8-bits to receive
 0A5  200C4    I2C_Rx_next_bit: CALL 0C4[I2C_Rx_bit]              ;receive and shift bit into LSB of s5
 0A6  19101                     SUB s1, 01[1'd]                   ;count bits received
 0A7  360A5                     JUMP NZ, 0A5[I2C_Rx_next_bit]
 0A8  25000                     RETURN 
 0A9                            ;
 0A9                            ;
 0A9                            ;------------------------------------------------------------------------------------------
 0A9                            ; Routine to transmit Acknowledge (ACK) from KCPSM6 master to a slave
 0A9                            ;------------------------------------------------------------------------------------------
 0A9                            ;
 0A9                            ; An Acknowledge (ACK) bit is transmitted to a slave after receiving a byte of data.
 0A9                            ;
 0A9                            ; ACK is simply the transmission of a '0' requiring the DATA line to be driven Low whilst
 0A9                            ; the CLK line is pulsed High.
 0A9                            ;
 0A9  200BE         I2C_Tx_ACK: CALL 0BE[I2C_data_Low]            ;DATA = 0
 0AA                            ;
 0AA  200CE      I2C_clk_pulse: CALL 0CE[I2C_delay_5us]
 0AB  200B8                     CALL 0B8[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0AC  200CF                     CALL 0CF[I2C_delay_4us]           ;clock pulse width
 0AD  200B4                     CALL 0B4[I2C_clk_Low]             ;end of CLK clock pulse includes 5us delay
 0AE  25000                     RETURN 
 0AF                            ;
 0AF                            ;
 0AF                            ;------------------------------------------------------------------------------------------
 0AF                            ; Routine to transmit No Acknowledge (NACK) from KCPSM6 master to a slave
 0AF                            ;------------------------------------------------------------------------------------------
 0AF                            ;
 0AF                            ; A No Acknowledge (NACK) bit is transmitted to a slave after receiving a byte of data and
 0AF                            ; typically used to signify to a slave that a read transaction has been completed.
 0AF                            ;
 0AF                            ; NACK is simply the transmission of a '1' requiring the DATA line to be driven High
 0AF                            ; whilst the CLK line is pulsed High.
 0AF                            ;
 0AF  200C1        I2C_Tx_NACK: CALL 0C1[I2C_data_Z]              ;DATA = Z (High)
 0B0  220AA                     JUMP 0AA[I2C_clk_pulse]           ;generate clock pulse (includes return)
 0B1                            ;
 0B1                            ;
 0B1                            ;------------------------------------------------------------------------------------------
 0B1                            ; Routine to receive and test the Acknowledge (ACK) from a slave
 0B1                            ;------------------------------------------------------------------------------------------
 0B1                            ;
 0B1                            ; The KCPSM6 master will receive an Acknowledge (ACK) bit from a slave following the
 0B1                            ; transmitted of a byte to the slave. Receiving an ACK indicates that the slave responded
 0B1                            ; as expected but receiving a No Acknowledge (NACK) implies that something went wrong!
 0B1                            ;
 0B1                            ; The KCPSM6 master will pulse the CLK line High and receive the acknowledge bit from the
 0B1                            ; slave. The received ACK bit will be returned in the least significant bit (LSB) of the
 0B1                            ; 's5' register. Furthermore, a test will be performed such that the CARRY flag will also
 0B1                            ; reveal if the bit was ACK or NACK.
 0B1                            ;
 0B1                            ;     Received ACK bit    Meaning      CARRY(C)
 0B1                            ;           0              ACK           0
 0B1                            ;           1              NACK          1
 0B1                            ;
 0B1                            ; Note that following the 'I2C_stop' routine the CARRY flag is '0'.
 0B1                            ;
 0B1  200C4         I2C_Rx_ACK: CALL 0C4[I2C_Rx_bit]              ;receive ACK bit into LSB of s5
 0B2  0D501                     TEST s5, 01[00000001'b]           ;set flags
 0B3  25000                     RETURN 
 0B4                            ;
 0B4                            ;
 0B4                            ;------------------------------------------------------------------------------------------
 0B4                            ; Subroutines used by the main I2C routines above
 0B4                            ;------------------------------------------------------------------------------------------
 0B4                            ;
 0B4                            ; These routines actually control the I2C signals an ensure that timing specifications
 0B4                            ; consistent with maximum bit rate of 100KHz are not exceeded.
 0B4                            ;
 0B4                            ;
 0B4                            ; Drive CLK Low and wait for 5us before doing anything else.
 0B4                            ;
 0B4  03FFE        I2C_clk_Low: AND sF, FE[~I2C_clk]              ;CLK = 0
 0B5  2DF20                     OUTPUT sF, 20[I2C_output_port]
 0B6  200CE                     CALL 0CE[I2C_delay_5us]
 0B7  25000                     RETURN 
 0B8                            ;
 0B8                            ;
 0B8                            ; Place CLK into tri-state (Z) so that it can go High.
 0B8                            ; Then wait for CLK to actually become High before returning because a slave
 0B8                            ; has the ability to stretch a clock to slow communication down.
 0B8                            ;
 0B8  05F01          I2C_clk_Z: OR sF, 01[I2C_clk]                ;CLK = Z
 0B9  2DF20                     OUTPUT sF, 20[I2C_output_port]
 0BA  09002  I2C_wait_clk_High: INPUT s0, 02[I2C_input_port]      ;read external signals
 0BB  0D001                     TEST s0, 01[I2C_clk]              ;test CLK bit
 0BC  320BA                     JUMP Z, 0BA[I2C_wait_clk_High]    ;wait if CLK held Low by slave
 0BD  25000                     RETURN 
 0BE                            ;
 0BE                            ;
 0BE                            ; Drive DATA Low and wait for 5us before doing anything else.
 0BE                            ;
 0BE  03FFD       I2C_data_Low: AND sF, FD[~I2C_data]             ;DATA = 0
 0BF  2DF20                     OUTPUT sF, 20[I2C_output_port]
 0C0  25000                     RETURN 
 0C1                            ;
 0C1                            ;
 0C1                            ; Place DATA into tri-state (Z) so that it can go High.
 0C1                            ; This can be used to transmit or receive a '1' but can also be used by the
 0C1                            ; slave to return a '0' by holding the data line Low against the pull-up resistor.
 0C1                            ;
 0C1  05F02         I2C_data_Z: OR sF, 02[I2C_data]               ;DATA = Z
 0C2  2DF20                     OUTPUT sF, 20[I2C_output_port]
 0C3  25000                     RETURN 
 0C4                            ;
 0C4                            ;
 0C4                            ; Receive one bit of data
 0C4                            ;
 0C4                            ; The bit received is shifted into the LSB of register 's5'.
 0C4                            ;
 0C4                            ; This the routine must be executed from the condition CLK low.
 0C4                            ;
 0C4                            ; The DATA line is released to allow a slave to transmit. There will be a
 0C4                            ; 5us delay before the CLK is released to start a clock pulse. The start of
 0C4                            ; the clock pulse can be delayed by a slave but a High duration of 4us is
 0C4                            ; guaranteed. The value of the DATA line is sampled at the mid-point of the
 0C4                            ; 4us high period (i.e. after 2us). The CLK clock pulse is followed by a
 0C4                            ; delay of 5us before anything else can happen.
 0C4                            ;
 0C4  200C1         I2C_Rx_bit: CALL 0C1[I2C_data_Z]              ;DATA = Z (slave can now drive)
 0C5  200CE                     CALL 0CE[I2C_delay_5us]
 0C6  200B8                     CALL 0B8[I2C_clk_Z]               ;CLK = Z (waits until definitely High)
 0C7  200D1                     CALL 0D1[I2C_delay_2us]           ;middle of SCL clock pulse
 0C8  09002                     INPUT s0, 02[I2C_input_port]      ;read external signals
 0C9  0D002                     TEST s0, 02[I2C_data]             ;set carry flag with value of DATA
 0CA  14500                     SLA s5                            ;shift received bit into LSB of s5
 0CB  200D1                     CALL 0D1[I2C_delay_2us]           ;complete 4us SCL clock pulse
 0CC  200B4                     CALL 0B4[I2C_clk_Low]             ;end of clock pulse includes 5us delay
 0CD  25000                     RETURN 
 0CE                            ;
 0CE                            ;
 0CE                            ; Software Delays for I2C Signal Timing
 0CE                            ;
 0CE  200D4      I2C_delay_5us: CALL 0D4[I2C_delay_1us]
 0CF  200D4      I2C_delay_4us: CALL 0D4[I2C_delay_1us]
 0D0  200D4                     CALL 0D4[I2C_delay_1us]
 0D1  200D4      I2C_delay_2us: CALL 0D4[I2C_delay_1us]
 0D2  200D4                     CALL 0D4[I2C_delay_1us]
 0D3  25000                     RETURN 
 0D4                            ;
 0D4                            ; The base delay is 1us and takes ((4 x I2C_time_reference) + 6) clock cycles
 0D4                            ; to execute including the CALL instruction required to invoke it.
 0D4                            ;
 0D4                            ; For example, if the clock frequency is 100MHz then 'I2C_time_reference' should be set
 0D4                            ; to 24'd. This will result in 24 iterations of the 'SUB' and 'JUMP NZ' loop resulting
 0D4                            ; in the execution of 48 instructions. The invoking 'CALL', the 'LOAD' and the 'RETURN'
 0D4                            ; bringing the total number of instructions to 51. All instructions take 2 clock cycles
 0D4                            ; to execute so that is a total of 102 clock cycles which take 1.02us at 100MHz.
 0D4                            ;  i.e. ((4 x I2C_time_reference) + 6) = ((4 x 24) + 6) = 102 clock cycles
 0D4                            ;
 0D4  01018      I2C_delay_1us: LOAD s0, 18[I2C_time_reference]
 0D5  19001     I2C_delay_loop: SUB s0, 01[1'd]
 0D6  360D5                     JUMP NZ, 0D5[I2C_delay_loop]
 0D7  25000                     RETURN 
 0D8                            ;
 0D8                            ;
 0D8                            ;------------------------------------------------------------------------------------------
 0D8                            ; End of 'i2c_routines.psm'
 0D8                            ;------------------------------------------------------------------------------------------
 0D8                            ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\wii_classic.psm
Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\soft_delays_100mhz.psm
Z:\Users\chadsutfin\Dropbox\vmshare\project\nesoc\fw\i2c_routines.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     00'd         
 timestamp_minutes   46'd         
 timestamp_seconds   26'd         
 datestamp_year      15'd         
 datestamp_month     12'd         
 datestamp_day       02'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 wii_classic_address 52           wii_classic.psm
 PA_BYTE_0           00           wii_classic.psm
 PA_BYTE_1           01           wii_classic.psm
 PA_BYTE_2           02           wii_classic.psm
 PA_BYTE_3           03           wii_classic.psm
 PA_BYTE_4           04           wii_classic.psm
 PA_BYTE_5           05           wii_classic.psm
 I2C_time_reference  24'd         i2c_routines.psm
 I2C_input_port      02           i2c_routines.psm
 I2C_output_port     20           i2c_routines.psm
 I2C_clk             00000001'b   i2c_routines.psm
 I2C_data            00000010'b   i2c_routines.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "02 Dec 2015"  
 timestamp$        "00:46:26"     



List of line labels

   Label               Addr  Source PSM File

   init                004   wii_classic.psm
   main                00E   wii_classic.psm
   error_handler       018   wii_classic.psm
   error_handler2      023   wii_classic.psm
   wii_classic_read    02B   wii_classic.psm
   wii_classic_init    053   wii_classic.psm
   delay_1ms           077   soft_delays_100mhz.psm
 * delay_20ms          07B   soft_delays_100mhz.psm
   delay_1s            07F   soft_delays_100mhz.psm
   software_delay      083   soft_delays_100mhz.psm
   I2C_initialise      089   i2c_routines.psm
   I2C_start           08D   i2c_routines.psm
   I2C_stop            094   i2c_routines.psm
   I2C_Tx_byte         09A   i2c_routines.psm
   I2C_Tx_next_bit     09B   i2c_routines.psm
   I2C_Tx1             09F   i2c_routines.psm
   I2C_Tx_tsu          0A0   i2c_routines.psm
   I2C_Rx_byte         0A4   i2c_routines.psm
   I2C_Rx_next_bit     0A5   i2c_routines.psm
   I2C_Tx_ACK          0A9   i2c_routines.psm
   I2C_clk_pulse       0AA   i2c_routines.psm
   I2C_Tx_NACK         0AF   i2c_routines.psm
   I2C_Rx_ACK          0B1   i2c_routines.psm
   I2C_clk_Low         0B4   i2c_routines.psm
   I2C_clk_Z           0B8   i2c_routines.psm
   I2C_wait_clk_High   0BA   i2c_routines.psm
   I2C_data_Low        0BE   i2c_routines.psm
   I2C_data_Z          0C1   i2c_routines.psm
   I2C_Rx_bit          0C4   i2c_routines.psm
   I2C_delay_5us       0CE   i2c_routines.psm
   I2C_delay_4us       0CF   i2c_routines.psm
   I2C_delay_2us       0D1   i2c_routines.psm
   I2C_delay_1us       0D4   i2c_routines.psm
   I2C_delay_loop      0D5   i2c_routines.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             35
 STAR              -

 AND               3
 OR                3
 XOR               -

 ADD               -
 ADDCY             -
 SUB               3
 SUBCY             2

 TEST              4
 TESTCY            -
 COMPARE           -
 COMPARECY         -

 SL0               3
 SL1               1
 SLX               -
 SLA               1
 RL                -
 SR0               1
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             2
 OUTPUT           25
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             20
 JUMP@             -
 CALL             87
 CALL@             -
 RETURN           26
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
